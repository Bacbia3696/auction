// Code generated by sqlc. DO NOT EDIT.
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    user_name,
    password,
    full_name,
    email,
    address,
    phone,
    birthdate,
    id_card,
    id_card_address,
    id_card_date,
    bank_id,
    bank_owner,
    bank_name,
    status,
    created_at,
    updated_at
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16)
RETURNING
    id, user_name, password, full_name, email, address, phone, birthdate, id_card, id_card_address, id_card_date, bank_id, bank_owner, bank_name, status, created_at, updated_at
`

type CreateUserParams struct {
	UserName      string       `json:"user_name"`
	Password      string       `json:"password"`
	FullName      string       `json:"full_name"`
	Email         string       `json:"email"`
	Address       string       `json:"address"`
	Phone         string       `json:"phone"`
	Birthdate     sql.NullTime `json:"birthdate"`
	IDCard        string       `json:"id_card"`
	IDCardAddress string       `json:"id_card_address"`
	IDCardDate    time.Time    `json:"id_card_date"`
	BankID        string       `json:"bank_id"`
	BankOwner     string       `json:"bank_owner"`
	BankName      string       `json:"bank_name"`
	Status        int32        `json:"status"`
	CreatedAt     time.Time    `json:"created_at"`
	UpdatedAt     sql.NullTime `json:"updated_at"`
}

// query.sql
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.UserName,
		arg.Password,
		arg.FullName,
		arg.Email,
		arg.Address,
		arg.Phone,
		arg.Birthdate,
		arg.IDCard,
		arg.IDCardAddress,
		arg.IDCardDate,
		arg.BankID,
		arg.BankOwner,
		arg.BankName,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Address,
		&i.Phone,
		&i.Birthdate,
		&i.IDCard,
		&i.IDCardAddress,
		&i.IDCardDate,
		&i.BankID,
		&i.BankOwner,
		&i.BankName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByEmail = `-- name: GetByEmail :one
SELECT id, user_name, password, full_name, email, address, phone, birthdate, id_card, id_card_address, id_card_date, bank_id, bank_owner, bank_name, status, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Address,
		&i.Phone,
		&i.Birthdate,
		&i.IDCard,
		&i.IDCardAddress,
		&i.IDCardDate,
		&i.BankID,
		&i.BankOwner,
		&i.BankName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByIdCard = `-- name: GetByIdCard :one
SELECT id, user_name, password, full_name, email, address, phone, birthdate, id_card, id_card_address, id_card_date, bank_id, bank_owner, bank_name, status, created_at, updated_at FROM users
WHERE id_card = $1 LIMIT 1
`

func (q *Queries) GetByIdCard(ctx context.Context, idCard string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByIdCard, idCard)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Address,
		&i.Phone,
		&i.Birthdate,
		&i.IDCard,
		&i.IDCardAddress,
		&i.IDCardDate,
		&i.BankID,
		&i.BankOwner,
		&i.BankName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByUserName = `-- name: GetByUserName :one
SELECT id, user_name, password, full_name, email, address, phone, birthdate, id_card, id_card_address, id_card_date, bank_id, bank_owner, bank_name, status, created_at, updated_at FROM users
WHERE user_name = $1 LIMIT 1
`

func (q *Queries) GetByUserName(ctx context.Context, userName string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByUserName, userName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Address,
		&i.Phone,
		&i.Birthdate,
		&i.IDCard,
		&i.IDCardAddress,
		&i.IDCardDate,
		&i.BankID,
		&i.BankOwner,
		&i.BankName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByUserNameActive = `-- name: GetByUserNameActive :one
SELECT id, user_name, password, full_name, email, address, phone, birthdate, id_card, id_card_address, id_card_date, bank_id, bank_owner, bank_name, status, created_at, updated_at FROM users
WHERE user_name = $1 AND status > 0 LIMIT 1
`

func (q *Queries) GetByUserNameActive(ctx context.Context, userName string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByUserNameActive, userName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Address,
		&i.Phone,
		&i.Birthdate,
		&i.IDCard,
		&i.IDCardAddress,
		&i.IDCardDate,
		&i.BankID,
		&i.BankOwner,
		&i.BankName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
